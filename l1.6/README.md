# Goroutine Stop Patterns

Практическая подборка из десяти способов корректно завершать работу горутин в Go. Каждый пример запускается последовательно в `main.go`, что позволяет увидеть различия в логах.

## Быстрый старт

```bash
go run .
```

Команда выводит поочередно результаты всех сценариев.

## Описанные техники

1. **Внутреннее условие** — горутина завершает цикл по достижении лимита и выходит через `return`.
2. **Уведомляющий канал** — внешний код закрывает/посылает сигнал в управляющий канал, горутина реагирует на `select` и завершает работу.
3. **`context.WithCancel`** — общий контекст отменяется, фоновые операции читают `ctx.Done()` и выходят.
4. **`context.WithTimeout`** — завершение по истечении заданного таймаута, удобно для ограниченных по времени операций.
5. **`runtime.Goexit`** — принудительно прекращает текущую горутину, при этом запуск `defer` выполняется.
6. **Закрытие рабочего канала** — потребитель читает `range` по каналу задач, выход из цикла происходит после `close(tasks)`.
7. **`panic`/`recover`** — демонстрирует жесткую остановку из глубины стека и обработку в `defer`, чтобы контроллер продолжил выполнение.
8. **OS-сигналы (`signal.Notify`)** — имитация graceful shutdown при получении `SIGINT`/`SIGTERM`.
9. **`context.WithDeadline`** — завершается по фиксированному времени, что отличается от относительного таймаута.
10. **Атомарный флаг (`atomic.Bool`)** — несколько инициаторов пытаются остановить воркер; флаг гарантирует единовременную очистку и закрытие каналов.
